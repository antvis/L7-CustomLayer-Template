export var frag =
  "\nuniform float u_opacity : 1.0;\nuniform float u_stroke_opacity : 1;\nuniform float u_stroke_width : 2;\nuniform vec4 u_stroke_color : [0.0, 0.0, 0.0, 0.0];\n\nvarying vec4 v_data;\nvarying vec4 v_color;\nvarying float v_radius;\n\n#pragma include \"sdf_2d\"\n#pragma include \"picking\"\n\nvoid main() {\n    int shape = int(floor(v_data.w + 0.5));\n\n    lowp float antialiasblur = v_data.z;\n    float r = v_radius / (v_radius + u_stroke_width);\n\n    float outer_df;\n    float inner_df;\n    // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'\n    if (shape == 0) {\n        outer_df = sdCircle(v_data.xy, 1.0);\n        inner_df = sdCircle(v_data.xy, r);\n    } else if (shape == 1) {\n        outer_df = sdEquilateralTriangle(1.1 * v_data.xy);\n        inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);\n    } else if (shape == 2) {\n        outer_df = sdBox(v_data.xy, vec2(1.));\n        inner_df = sdBox(v_data.xy, vec2(r));\n    } else if (shape == 3) {\n        outer_df = sdPentagon(v_data.xy, 0.8);\n        inner_df = sdPentagon(v_data.xy, r * 0.8);\n    } else if (shape == 4) {\n        outer_df = sdHexagon(v_data.xy, 0.8);\n        inner_df = sdHexagon(v_data.xy, r * 0.8);\n    } else if (shape == 5) {\n        outer_df = sdOctogon(v_data.xy, 1.0);\n        inner_df = sdOctogon(v_data.xy, r);\n    } else if (shape == 6) {\n        outer_df = sdHexagram(v_data.xy, 0.52);\n        inner_df = sdHexagram(v_data.xy, r * 0.52);\n    } else if (shape == 7) {\n        outer_df = sdRhombus(v_data.xy, vec2(1.0));\n        inner_df = sdRhombus(v_data.xy, vec2(r));\n    } else if (shape == 8) {\n        outer_df = sdVesica(v_data.xy, 1.1, 0.8);\n        inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);\n    }\n\n    float opacity_t = smoothstep(0.0, antialiasblur, outer_df);\n\n    float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(\n        antialiasblur,\n        0.0,\n        inner_df\n    );\n\n    if(u_stroke_width < 0.01) {\n        gl_FragColor = vec4(v_color.rgb, v_color.a * u_opacity);\n    } else {\n        gl_FragColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), u_stroke_color * u_stroke_opacity, color_t);\n    }\n\n    gl_FragColor.a *= opacity_t;\n    gl_FragColor = filterColor(gl_FragColor);\n}\n";
export var vert =
  '\nattribute vec4 a_Color;\nattribute vec3 a_Position;\nattribute vec3 a_Extrude;\nattribute float a_Size;\nattribute float a_Shape;\n\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_Mvp;\n\nvarying vec4 v_data;\nvarying vec4 v_color;\nvarying float v_radius;\n\nuniform float u_stroke_width : 2;\n\n\n#pragma include "projection"\n#pragma include "picking"\n\n\nvoid main() {\n    vec3 extrude = a_Extrude;\n    float shape_type = a_Shape;\n\n    float newSize = setPickingSize(a_Size);\n\n    v_color = a_Color;\n\n    v_radius = newSize;\n\n\n    float antialiasblur = -max(2.0 / u_DevicePixelRatio / newSize, 0.0);\n\n    vec2 offset = project_pixel(extrude.xy * (newSize + u_stroke_width));\n\n    v_data = vec4(extrude.x, extrude.y, antialiasblur, shape_type);\n\n    vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\n        gl_Position = u_Mvp * vec4(project_pos.xy + offset, 0.0, 1.0);\n    } else {\n        gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\n    }\n\n    setPickingColor(a_PickingColor);\n}\n';
